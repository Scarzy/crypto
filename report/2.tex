\section{Hamming Codes}

\subsection{a}
\label{sec:2a}
The first steps taken were to determine if the functions were reducible or not, as reducible functions can not be generator functions.
This is because the generators must produce a cyclic code with a minimum hamming distance of 3, and only primitive polynomials can provide this.
All primitive polynomials are irreducible by definition.

\subsubsection{i}

$f_{1}(x) = x^{6} + x^{3} + x^{2} + x + 1$ \\

\noindent $f_{1}(x)$ is reducible, and can be factored to: \\

\noindent $f_{1}(x) = (x^{2} + x + 1)(x^{4} + x^{3} + 1)$

\subsubsection{ii}

$f_{2}(x) = x^{6} + x^{5} + x^{4} + x^{3} + 1$ \\

\noindent $f_{2}(x)$ is reducible, and can be factored to: \\

\noindent $f_{2}(x) = (x^{2} + x + 1)(x^{4} + x + 1)$

\subsubsection{iii}

$f_{3}(x) = x^{6} + x^{5} + x$ \\

\noindent $f_{3}(x)$ is reducible, and can be factored to: \\

\noindent $f_{3}(x) = x(x^{2} + x + 1)(x^{3} + x + 1)$

\subsubsection{iv}

$f_{4}(x) = x^{6} + x^{5} + x^{4} + x^{3} + x^{2} + x + 1$ \\

\noindent $f_{4}(x)$ is reducible, and can be factored to: \\

\noindent $f_{4}(x) = (x^{3} + x + 1)(x^{3} + x^{2} + 1)$

\subsubsection{v}

$f_{5}(x) = x^{6} + x + 1$ \\

\noindent This function is irreducible.

$f_{5}(x)$ is an appropriate generator polynomial.
All the factors shown here were sourced from \cite{website:Polynomials}.

\subsection{b}
The first observation we make is that $n = 63$, which leads us to determine that \\ $ n = 2^{m}-1 \\ m = log_{2}(n+1) \\ m = log_{2}(64) \\ m = 6$ \\
Which allows us to prove that \\ $k = 2^{m} - m - 1 \\ k = 2^{6} - 6 - 1 \\ k = 64 - 7 \\ k = 57$ \\
Using these observations, and the generator polynomial from \ref{sec:2a}, it is possible to produce the generator and parity check matrices.
The parity check polynomial $h(x)$ was constructed first, by calculating: \\
$h(x) = \frac{x^{n} + 1}{g(x)} \\ 
h(x) = \frac{x^{63} + 1}{x^{6} + x + 1}$\\

It was required that this division prove successful, as $g(x)$ has to be a prime factor of $x^{n} + 1$.
This division was successful, and the division can be seen at the end of this document.
$G$ was constructed by continuously shifting the values from the generator polynomial $g(x)$.
$H$ was constructed by shifting the values from the parity check polynomial $h(x)$ along.
These two matrices are included on A3 paper at the end of this document.

\subsection{c}
These can be determined to be valid codewords or not by multiplying the codeword by the transpose of the parity check matrix.
This will give us the syndrome, $S$.
If this syndrome is equal to 0, then it is a valid codeword.
If not, the syndrome gives the position of the incorrect bit, which when inverted produces a valid codeword.

\subsubsection{i}
$m1$ = 101001111000000000000000000000000000000000000000000000000000000	\\

$S = m1 \times H^{T}$ \\
\[ S = \left[ \begin{array}{cccccc} 1 & 0 & 1 & 1 & 0 & 1 \end{array} \right] \]

This shows that $m1$ is not a valid codeword, however potentially could be one with a single bit error.
This bit error could be corrected to give the valid codeword:

\noindent $m1$ = 101001111000000000000000000000000000010000000000000000000000000

\subsubsection{ii}
$m2$ = 100001100000000000000000000000000000000000000000000000001000011	\\

$S = m2 \times H^{T}$ \\
\[ S = \left[ \begin{array}{cccccc} 0 & 0 & 1 & 1 & 0 & 1 \end{array} \right] \]

This shows that $m2$ is not a valid codeword, however potentially could be one with a single bit error.
This bit error could be corrected to give the valid codeword:

$m2$ = 100001100000000000000000000000000000000000001000000000001000011	\\

\subsubsection{iii}
$m3$ = 100001100000000000000000000010000000000000000000000000001000011	\\

$S = m3 \times H^{T}$ \\
\[ S = \left[ \begin{array}{cccccc} 0 & 0 & 0 & 0 & 1 & 1 \end{array} \right] \]

This shows that $m2$ is not a valid codeword, however potentially could be one with a single bit error.
This bit error could be corrected to give the valid codeword:

$m3$ = 100001100000000000000000000010000000000000000000000000001000001

None of the code words were valid, however potentially were a single bit different to one.
Although there was a difference of only 1 bit between $m2$ and $m3$, they did not produce the same corrected code word.
This implies that the bit change between the two introduced a second error into one of them.
As this hamming code can only correct a single bit error, a second error would cause it to correct to a different code word.
